day07-爬虫7

1、多任务
	什么是多任务？
	生活中：唱歌跳舞、吃肉喝酒
	程序中：一个函数，称之为一个任务，
	程序中实现多任务，两种方法：多进程-多线程
	同步、异步、并行、并发
	ajax，发送请求==得到响应==处理响应
	同步：先执行任务a，在执行任务b
	异步：任务a和任务b同时执行
	并行：任务a和任务b真正的在同时运行    真异步
	并发：任务a和任务b，通过快速切换，达到同时运行的效果，其实不是真正的同时运行  伪异步
	计算机中：sublime、录屏、vnc、文件资源管理器，。。。并发实现，通过cpu的快速切换实现的
2、多进程
	进程：process，在你的电脑中，一个应用程序就是一个进程
	代码中：代码在没有运行的时候，称之为程序，在运行的时候，就是一个进程
		以前写的代码都只有一个进程，称之为主进程，通过主进程要再去创建子进程
	linux  干掉进程： ps -ef | grep ssh    杀死一个进程：  kill -9 进程id号(pid)
	进程创建：
	面向过程
		主进程   唱歌进程   跳舞进程
		p = Process(target=xxx, args=(xxx,))
		target: 进程启动之后要执行的函数
		args: 主进程给子进程传递的参数，是一个元组
		p.start(): 启动进程
		p.join(): 让主进程等待
		import os
		os.getpid(): 得到当前进程id
		os.getppid(): 得到当前进程父进程id
	面向对象
		class MyProcess(Process):
			def run(self):
				pass
		如果要写构造方法，要手动调用父类的构造方法
	进程之间是否共享局部变量
		不共享
	进程之间是否共享全局变量；

​		不共享
​	进程都有单独的自己的空间，每一个进程都有自己独有的一份代码
​	进程池
​		进程是不是创建的越多越好？比如拷贝文件，一个文件夹里面有100个文件，拷贝这个文件夹里面100个文件。使用多进程拷贝，那你要不要开100个进程
​		所以进程不是创建的越多越好，合理最好，单进程一定比多进程慢吗?
​		我们的做法是创建5个进程，然后完成100个任务，这就是进程池的概念，在池子里面创建进程的个数是有限的，任务随便添加，然后用这些进程将这所有的任务全部执行完毕
3、多线程
​	什么是线程？（thread）
​	vnc启动了，录制视频，录制语音都在同时录制，同时工作，录制视频的、录制语音的可以理解为线程
​	qq启动，在视频的时候，可以视频，可以语音，可以发qq，视频、语音、qq就可以理解为是线程
​	线程和进程的关系？
​	（1）一个线程只能属于一个进程，而一个进程可以有多个线程，如果只有一个线程，称之为主线程
​	（2）计算机在分配资源，是按照进程分配的，如果进程里面有好多线程，那么这些线程共享这些资源
​	（3）cpu切换的基本单位，是线程
​	多进程：进程之间相互切换消耗资源和时间，如果一个子进程挂了，不影响其他的进程，稳定
​	多线程：线程之间切换相对进程消耗资源要少，如果一个子线程挂了，整个进程就崩溃了，不稳定
​	面向过程创建
​		t = threading.Thread(target=xxx, name=xxx, args=(xxx,))
​		t.start(): 启动线程
​		t.join(): 主线程等待子线程结束
​		target: 线程启动之后，目标函数
​		name: 给线程起名字，threading.current_thread().name
​		args: 给线程传递参数
​	面向对象创建
​		class MyThread(threading.Thread):
​			def run(self):
​				pass
​		如果需要传递参数，重写构造方法，需要手动调用父类构造方法
​	线程之间是否共享局部变量
​		不共享
​	线程之间是否共享全局变量
​		共享
​	线程安全
​		线程锁
​		lock = threading.Lock()
​		上锁
​		lock.acquire()
​		释放锁
​		lock.release()
​	队列
​		queue, 队列，先进先出
​		创建队列，指定长度，不指定，默认无限长
​		q = Queue(5)
​		q.put('')    如果队列满，默认一直等待
​		q.put('', False)  如果队列满，立马抛出异常
​		q.put('', True, 5)  如果队列满，等5秒钟抛出异常

		获取元素
		q.get()      如果队列为空，默认一直等待
		q.get(False)  如果队列为空，立马抛出异常
		q.get(True, 5)  如果队列为空，等5s抛出异常
	
		q.full()    判断队列是否已满
		q.empty()   判断队列是否为空
		q.qsize()   得到队列中元素的个数  
4、多线程爬虫
	线程-队列
	生产者（生产数据）-消费者（消费数据）模型
	while 1:
		生产数据
		消费数据
	生产数据：搞几个线程用来生产数据，将数据存入队列中
		队列
	消费数据：搞几个线程用来消费数据，从队列中获取数据
	耦合度，高内聚、低耦合

	爬虫中，可否使用生产者消费者模型？
	爬虫流程：
	（1）给一个url
	（2）发送请求，得到响应内容
	（3）解析响应内容
	（4）保存数据
	for page in xxx:
		url = xxx
		r = requests.get(url)
		parse_content(r.text)
